一、
happens-before:如果两个操作之间具有happens-before 关系，那么前一个操作的结果就会对后面一个操作可见。 
1.程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 
2.监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 
3.volatile变量规则：对一个volatile域的写，happens- before于任意后续对这个volatile域的读。 
4.传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。 
5.线程启动规则：Thread对象的start()方法happens- before于此线程的每一个动作。

二、
Volatile和Synchronized四个不同点： 
1 粒度不同，前者针对变量 ，后者锁对象和类 
2 syn阻塞，volatile线程不阻塞 
3 syn保证三大特性，volatile不保证原子性 
4 syn编译器优化，volatile不优化 
volatile具备两种特性： 
1. 保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。 
2. 禁止指令重排序优化。 
Volatile如何保证内存可见性: 
1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。 
2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。 
异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。 
打电话和发短信来比喻同步和异步操作。 
阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。 
非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。 
非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。

三、CAS
CAS（Compare And Swap） 无锁算法： 
CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被
挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同
时，将内存值V修改为B，否则什么都不做。

四、类加载器
类加载器工作机制： 
1.装载：将Java二进制代码导入jvm中，生成Class文件。 
2.连接：a）校验：检查载入Class文件数据的正确性 b）准备：给类的静态变量分配存储空间 c）解析：将符号引用转成直接引用 
3：初始化：对类的静态变量，静态方法和静态代码块执行初始化工作。

双亲委派模型：类加载器收到类加载请求，首先将请求委派给父类加载器完成 
用户自定义加载器->应用程序加载器->扩展类加载器->启动类加载器。

五、一致性哈希：
Memcahed缓存： 
数据结构：key,value对 
使用方法：get,put等方法

六、Redis数据结构: 
String—字符串（key-value 类型） 
Hash—字典(hashmap) Redis的哈希结构可以使你像在数据库中更新一个属性一样只修改某一项属性值 
List—列表 实现消息队列 
Set—集合 利用唯一性 
Sorted Set—有序集合 可以进行排序 
可以实现数据持久化

七、索引：B+，B-,全文索引 
Mysql的索引是一个数据结构，旨在使数据库高效的查找数据。 
常用的数据结构是B+Tree，每个叶子节点不但存放了索引键的相关信息还增加了指向相邻叶子节点的指针，这样就形成了带有顺序访问指针的B+Tree，做这个优化的目的是提高不同区间访问的性能。 
什么时候使用索引： 
1. 经常出现在group by,order by和distinc关键字后面的字段 
2. 经常与其他表进行连接的表，在连接字段上应该建立索引 
3. 经常出现在Where子句中的字段 
4. 经常出现用作查询选择的字段

八、代理
代理的共有优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。 
Java静态代理： 
代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，代理对象可以在调用目标对象相应方法前后加上其他业务处理逻辑。 
缺点：一个代理类只能代理一个业务类。如果业务类增加方法时，相应的代理类也要增加方法。 
Java动态代理： 
Java动态代理是写一个类实现InvocationHandler接口，重写Invoke方法，在Invoke方法可以进行增强处理的逻辑的编写，这个公共代理类在运行的时候才能明确自己要代理的对象，同时可以实现该被代理类的方法的实现，然后在实现类方法的时候可以进行增强处理。 
实际上：代理对象的方法 = 增强处理 + 被代理对象的方法

JDK和CGLIB生成动态代理类的区别： 
JDK动态代理只能针对实现了接口的类生成代理（实例化一个类）。此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑 
CGLIB是针对类实现代理，主要是对指定的类生成一个子类（没有实例化一个类），覆盖其中的方法 。 
Spring AOP应用场景 
性能检测，访问控制，日志管理，事务等。 
默认的策略是如果目标类实现接口，则使用JDK动态代理技术，如果目标对象没有实现接口，则默认会采用CGLIB代理。

九、